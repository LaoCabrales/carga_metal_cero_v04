# -*- coding: utf-8 -*-
"""carga_mental_cero_v04.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SX42bFQ8_WToKD5VsT4K_IbPAOP4UHAl
"""

import streamlit as st
from datetime import date
import pandas as pd
import uuid
import locale # Importar locale para el idioma

# --- CONFIGURACI√ìN DEL IDIOMA ---
# Establecer el locale a espa√±ol para que strftime use nombres de d√≠as y meses en espa√±ol
try:
    locale.setlocale(locale.LC_TIME, 'es_ES.UTF-8')
except locale.Error:
    try:
        locale.setlocale(locale.LC_TIME, 'es_ES')
    except locale.Error:
        # Si las opciones espec√≠ficas fallan, se mantiene el locale por defecto (ej. 'en_US')
        pass

# --- CONFIGURACI√ìN DE LA P√ÅGINA ---
st.set_page_config(
    page_title="Task Organizer: Carga Mental Cero",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- ESTILOS CSS PERSONALIZADOS ---
# Inyectar CSS para modificar el color del texto de st.caption (subt√≠tulos)
# Streamlit usa la clase .st-emotion-cache-1gcsx22 para los subt√≠tulos (depende de la versi√≥n)
# Pero usaremos una soluci√≥n m√°s gen√©rica si es posible, o marcadores directos.

CAPTION_STYLE = """
<style>
/* Estilo para los subt√≠tulos de las listas de tareas (Secci√≥n 1) */
.stCaption:nth-child(2) > div,
/* Estilo para el subt√≠tulo del calendario (Secci√≥n 2) */
.stCaption:nth-child(5) > div {
    color: #000000 !important; /* Forzar color negro */
    font-weight: 500;
}

/* Soluci√≥n alternativa/m√°s robusta para subt√≠tulos generales en caso de que la primera falle: */
/* Busca el elemento div que contiene el texto del caption y aplica el estilo */
div[data-testid="stCaptionContainer"] {
    color: #000000 !important;
}
</style>
"""
st.markdown(CAPTION_STYLE, unsafe_allow_html=True)


# --- INICIALIZACI√ìN DEL ESTADO DE SESI√ìN ---
# Se utiliza el estado de sesi√≥n de Streamlit para almacenar las tareas de forma persistente
if 'tasks' not in st.session_state:
    st.session_state.tasks = []

# --- CONSTANTES DE CATEGOR√çA Y ESTILOS ---
CATEGORIES = {
    "üî¥ Urgente": {"color": "#FF4B4B", "label": "Urgente"},      # Rojo
    "üü† Importante": {"color": "#FFA500", "label": "Importante"},  # Naranja
    "üü° Pendiente": {"color": "#FFD700", "label": "Pendiente"}   # Amarillo/Dorado
}

# --- FUNCIONES AUXILIARES ---

def remove_task(task_id):
    """Elimina una tarea por su ID. El rerun es manejado por el on_click del bot√≥n."""
    st.session_state.tasks = [task for task in st.session_state.tasks if task["id"] != task_id]
    # No se requiere st.experimental_rerun() porque el on_click lo dispara autom√°ticamente al modificar st.session_state

def add_task(description, category_key, due_date):
    """Agrega una nueva tarea a la lista de tareas en el estado de sesi√≥n."""
    if description:
        # Extraer el nombre de la categor√≠a (sin el emoji)
        category_name = CATEGORIES[category_key]["label"]

        # Crear la estructura de la nueva tarea
        new_task = {
            "id": str(uuid.uuid4()), # ID √∫nico para el manejo de tareas
            "description": description,
            "category": category_name,
            "category_key": category_key, # Guarda la clave con el emoji para color
            "date": due_date
        }
        st.session_state.tasks.append(new_task)
        # Limpiar el formulario despu√©s de agregar la tarea
        st.session_state.new_task_description = ""
        st.success("¬°Tarea agregada exitosamente!")
    else:
        st.error("La descripci√≥n de la tarea no puede estar vac√≠a.")

def update_task_date(task_id, new_date):
    """Actualiza la fecha de una tarea por su ID."""
    for i, t in enumerate(st.session_state.tasks):
        if t["id"] == task_id:
            st.session_state.tasks[i]["date"] = new_date
            return True
    return False

def move_task_to_calendar_callback(task_id):
    """
    Callback ejecutado al presionar 'Mover a Calendario'.
    Lee la fecha del st.date_input asociado (usando su clave) y actualiza la tarea.
    """
    # La clave del date_input en el popover es f"popover_date_{task_id}"
    date_key = f"popover_date_{task_id}"

    # Obtener la fecha seleccionada directamente del estado de sesi√≥n
    new_date = st.session_state.get(date_key)

    if new_date:
        if update_task_date(task_id, new_date):
            # *** SOLUCI√ìN: Se elimin√≥ st.experimental_rerun() ***
            # La modificaci√≥n de st.session_state dentro del on_click es suficiente
            # para que Streamlit haga un rerun de forma autom√°tica y estable.
            pass
    # No se maneja el error aqu√≠, ya que el control de fecha lo hace st.date_input


# --- L√ìGICA DE CLASIFICACI√ìN ---

def get_tasks_by_status():
    """Clasifica las tareas en listas sin fecha y tareas con fecha (calendario)."""

    # Inicializar el diccionario con los nombres de las categor√≠as como claves.
    tasks_no_date = {data["label"]: [] for data in CATEGORIES.values()}
    tasks_with_date = []

    for task in st.session_state.tasks:
        cat_label = CATEGORIES[task["category_key"]]["label"]
        if task["date"] is None:
            tasks_no_date[cat_label].append(task)
        else:
            tasks_with_date.append(task)

    # Ordenar las tareas con fecha cronol√≥gicamente
    tasks_with_date.sort(key=lambda x: x["date"])

    return tasks_no_date, tasks_with_date

# --- UI: ENTRADA DE TAREAS (SIDEBAR) ---

with st.sidebar:
    st.title("‚ûï Organiza tu Carga Mental")
    st.markdown("---")

    st.header("Nueva Tarea")

    # 1. Descripci√≥n de la tarea
    description = st.text_input(
        "1. Describe la tarea:",
        key="new_task_description",
        placeholder="Ejemplo: Preparar informe mensual"
    )

    # 2. Nivel de Urgencia
    category = st.radio(
        "2. Nivel de urgencia:",
        options=CATEGORIES.keys(),
        index=1, # Por defecto 'Importante'
        horizontal=True,
        key="new_task_category"
    )

    # 3. Fecha espec√≠fica (Opcional)
    has_date = st.checkbox("¬øTiene fecha espec√≠fica?", key="has_date_checkbox")
    due_date = None
    if has_date:
        due_date = st.date_input("3. Elige la fecha:", min_value=date.today(), key="new_task_date")

    # Bot√≥n para agregar la tarea
    st.button(
        "Guardar Tarea",
        on_click=add_task,
        args=(description, category, due_date if has_date else None),
        type="primary",
        use_container_width=True
    )
    st.markdown("---")
    st.markdown("ü§ñ **Objetivo:** Disminuir tu carga mental al visualizar y clasificar tus compromisos.")

# --- UI: PANTALLA PRINCIPAL ---

# Obtener tareas clasificadas
tasks_no_date, tasks_with_date = get_tasks_by_status()

st.title("üìÖ Tablero de Tareas Diarias")

# --- SECCI√ìN 1: TAREAS POR ASIGNAR (LISTAS POR CATEGOR√çA) ---

st.header("Lista de Tareas Pendientes (Sin Fecha Asignada)")
st.caption("Estas tareas necesitan que les asignes una fecha para moverlas al calendario.")

# Crear tres columnas para las listas de tareas
col1, col2, col3 = st.columns(3)

def display_task_list(column, category_label, tasks):
    """Muestra una lista de tareas en una columna con el estilo de su categor√≠a."""
    category_data = next((v for k, v in CATEGORIES.items() if v["label"] == category_label), None)
    color = category_data["color"] if category_data else "#CCCCCC"

    with column:
        # Estilo para el encabezado de la lista
        st.markdown(
            f"""
            <div style="background-color: {color}; padding: 10px; border-radius: 8px 8px 0 0; color: white; text-align: center; font-weight: bold;">
                {category_label.upper()} ({len(tasks)})
            </div>
            """,
            unsafe_allow_html=True
        )

        if not tasks:
            st.info("¬°No hay tareas en esta categor√≠a!")

        for task in tasks:
            st.markdown(
                f"""
                <div style="border: 1px solid {color}; border-radius: 0 0 8px 8px; margin-top: -1px; padding: 10px; display: flex; justify-content: space-between; align-items: center;">
                    <span style="flex-grow: 1; margin-right: 10px;">{task['description']}</span>
                </div>
                """,
                unsafe_allow_html=True
            )

            # Contenedor para los botones
            col_popover, col_btn_del = st.columns([4, 1])

            with col_btn_del:
                # Usar on_click para mayor estabilidad al eliminar la tarea
                st.button(
                    "üóëÔ∏è",
                    key=f"del_no_date_{task['id']}",
                    on_click=remove_task,
                    args=(task['id'],),
                    help="Eliminar tarea"
                )

            with col_popover:
                # Bot√≥n para asignar fecha y mover al calendario
                with st.popover("üìÖ Asignar Fecha", use_container_width=True):
                    # El date_input establece su valor en st.session_state[key]
                    st.date_input(
                        "Selecciona una fecha para esta tarea:",
                        min_value=date.today(),
                        key=f"popover_date_{task['id']}" # La clave que usar√° el callback
                    )

                    # El bot√≥n usa on_click para llamar a la funci√≥n que leer√° el valor de la fecha
                    st.button(
                        "Mover a Calendario",
                        key=f"move_to_cal_{task['id']}",
                        on_click=move_task_to_calendar_callback, # Usar callback
                        args=(task['id'],),
                        type="primary",
                        use_container_width=True
                    )

# Mostrar las tres listas
display_task_list(col1, "Urgente", tasks_no_date["Urgente"])
display_task_list(col2, "Importante", tasks_no_date["Importante"])
display_task_list(col3, "Pendiente", tasks_no_date["Pendiente"])

st.markdown("---")

# --- SECCI√ìN 2: CALENDARIO (TAREAS ASIGNADAS) ---

st.header("üóìÔ∏è Tareas Asignadas a Fecha (Calendario)")
# Se incluye el subt√≠tulo din√°mico con el color de letra forzado a negro
st.caption(f"Tienes **{len(tasks_with_date)}** tareas programadas.")

if not tasks_with_date:
    st.info("¬°No tienes tareas con fecha espec√≠fica a√∫n! Agr√©galas o as√≠gnales una fecha desde las listas.")
else:
    # Agrupar las tareas por fecha
    tasks_by_date = {}
    for task in tasks_with_date:
        # Convertir la fecha a string para usarla como clave y capitalizar la primera letra.
        # El capitalize() asegura que el d√≠a de la semana inicie con may√∫scula gracias al locale.
        date_str = task["date"].strftime("%A, %d de %B de %Y").capitalize()
        if date_str not in tasks_by_date:
            tasks_by_date[date_str] = []
        tasks_by_date[date_str].append(task)

    for date_str, tasks in tasks_by_date.items():
        # Usar un expander para agrupar las tareas por d√≠a (estilo calendario)
        # Determinar el color de borde/√©nfasis por la tarea m√°s urgente del d√≠a
        tasks.sort(key=lambda t: list(CATEGORIES.keys()).index(t['category_key']))
        top_color = CATEGORIES[tasks[0]['category_key']]['color']

        with st.expander(f"**{date_str}** ({len(tasks)} Tareas)", expanded=True):
            st.markdown(
                f'<style>.stExpanderDetails {{ border-left: 5px solid {top_color}; padding-left: 10px; }}</style>',
                unsafe_allow_html=True
            )
            for task in tasks:
                color = CATEGORIES[task["category_key"]]["color"]

                # Dise√±o de tarjeta para cada tarea en el calendario
                col_desc, col_complete, col_btn_del = st.columns([4, 1, 1])

                with col_desc:
                    st.markdown(
                        f"""
                        <div style="background-color: #f0f2f6; border-left: 5px solid {color}; padding: 10px; margin-bottom: 5px; border-radius: 4px; display: flex; align-items: center;">
                            <strong style="margin-right: 10px;">{task['category_key'].split(' ')[0]}</strong>
                            <span>{task['description']}</span>
                        </div>
                        """,
                        unsafe_allow_html=True
                    )

                # --- BOT√ìN: MARCAR COMO COMPLETADA (USA on_click) ---
                with col_complete:
                    st.button(
                        "‚úÖ",
                        key=f"complete_{task['id']}",
                        on_click=remove_task,
                        args=(task['id'],),
                        help="Marcar como realizada (Completar)",
                        type="secondary"
                    )

                with col_btn_del:
                    # --- BOT√ìN: ELIMINAR TAREA (USA on_click) ---
                    st.button(
                        "üóëÔ∏è",
                        key=f"del_date_{task['id']}",
                        on_click=remove_task,
                        args=(task['id'],),
                        help="Eliminar tarea"
                    )